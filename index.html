<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Badgey</title>
  <link rel="icon" type="image/png" sizes="192x192" href="/spudz_free.png" />
  <link rel="apple-touch-icon" href="/spudz_free.png" />
  <style>
    :root {
      --accent-main: #f84979;
      --accent-dark: #d63c66;
      --accent-darker: #b32d52;
      --white: #ffffff;
      --neutral-50: #fafafa;
      --neutral-100: #f4f4f5;
      --neutral-200: #e4e4e7;
      --neutral-300: #d4d4d8;
      --neutral-400: #a1a1aa;
      --neutral-600: #696968;
      --neutral-800: #3e3e3e;
      --black: #000000;
      --background: var(--neutral-50);
      --text-primary: var(--neutral-800);
      --text-secondary: var(--neutral-600);
      --primary: var(--accent-main);
      --primary-hover: var(--accent-dark);
      --primary-foreground: var(--white);
      --secondary-bg: var(--neutral-100);
      --secondary-border: var(--neutral-300);
      --border: var(--neutral-200);
      --shadow-color: rgba(0, 0, 0, 0.12);
    }
    
    @media (prefers-color-scheme: dark) {
      :root {
        --background: var(--neutral-800);
        --text-primary: var(--neutral-100);
        --text-secondary: var(--neutral-400);
        --border: #404040;
        --secondary-bg: #333333;
        --secondary-border: #505050;
        --shadow-color: rgba(0, 0, 0, 0.4);
      }
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'Segoe UI', sans-serif;
      background: var(--background);
      color: var(--text-primary);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      overflow-x: hidden;
    }

    /* Parallax Background Layers */
    .parallax-bg {
      position: fixed;
      inset: 0;
      z-index: -10;
      overflow: hidden;
    }

    .bg-layer {
      position: absolute;
      inset: 0;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
    }

    .bg-layer-1 {
      background-image: url('bg/background1.png');
      z-index: 1;
    }

    .bg-layer-2 {
      background-image: url('bg/background2.png');
      z-index: 2;
    }

    .bg-layer-3 {
      background-image: url('bg/background3.png');
      z-index: 3;
    }

    /* Floating Clouds */
    .clouds-container {
      position: absolute;
      inset: 0;
      z-index: 4;
      pointer-events: none;
    }

    .cloud {
      position: absolute;
      background-size: contain;
      background-repeat: no-repeat;
      opacity: 0.8;
      will-change: transform;
    }

    @keyframes drift-slow {
      0% { transform: translateX(-20%); }
      100% { transform: translateX(120vw); }
    }

    header {
      padding: 1rem 1.5rem;
      display: flex;
      justify-content: center;
    }

    main {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      gap: 2.5rem;
    }

    .logo-container {
      position: relative;
      cursor: pointer;
      -webkit-user-select: none;
      user-select: none;
    }

    .logo {
      width: 180px;
      height: 180px;
      transition: transform 0.1s ease;
    }

    /* Canvas replaces img for eye-tracking; same sizing */
    #spudzCanvas {
      width: 180px;
      height: 180px;
      transition: transform 0.1s ease;
    }

    .logo-container:active .logo,
    .logo-container:active #spudzCanvas {
      transform: scale(0.95);
    }

    .ow-text {
      position: absolute;
      top: -10px;
      right: -20px;
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--accent-main);
      opacity: 0;
      transform: rotate(12deg);
      pointer-events: none;
      transition: opacity 0.1s ease;
    }

    .ow-text.show {
      opacity: 1;
    }

    .buttons {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      justify-content: center;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      text-decoration: none;
      color: var(--primary-foreground);
      background: var(--primary);
      padding: 0.875rem 2.5rem;
      border-radius: 999px;
      font-weight: 600;
      font-size: 1rem;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
      box-shadow: 0 4px 16px rgba(248, 73, 121, 0.3);
    }

    .btn:hover {
      background: var(--primary-hover);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(248, 73, 121, 0.4);
    }

    .btn-secondary {
      background: var(--secondary-bg);
      color: var(--text-primary);
      border: 1px solid var(--secondary-border);
      box-shadow: 0 2px 8px var(--shadow-color);
    }

    .btn-secondary:hover {
      background: var(--neutral-200);
      box-shadow: 0 4px 12px var(--shadow-color);
    }

    @media (prefers-color-scheme: dark) {
      .btn-secondary:hover {
        background: #444444;
      }
    }

    footer {
      padding: 1.5rem;
      text-align: center;
      border-top: 1px solid var(--border);
    }

    .other-toggle {
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 0.8rem;
      cursor: pointer;
      padding: 0.25rem 0.5rem;
      opacity: 0.6;
      transition: opacity 0.2s ease;
    }

    .other-toggle:hover {
      opacity: 1;
    }

    .other-links {
      display: none;
      flex-wrap: wrap;
      gap: 0.75rem;
      justify-content: center;
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid var(--border);
    }

    .other-links.show {
      display: flex;
    }

    .other-links a {
      color: var(--text-secondary);
      text-decoration: none;
      font-size: 0.85rem;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      transition: color 0.2s ease, background 0.2s ease;
    }

    .other-links a:hover {
      color: var(--text-primary);
      background: var(--secondary-bg);
    }

    @media (max-width: 480px) {
      .logo,
      #spudzCanvas {
        width: 140px;
        height: 140px;
      }

      .buttons {
        flex-direction: column;
        width: 100%;
        max-width: 280px;
      }

      .btn {
        width: 100%;
      }
    }

    /* Frog Canvas Layer */
    #frogCanvas {
      position: fixed;
      inset: 0;
      z-index: -1;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <!-- Parallax Background -->
  <div class="parallax-bg">
    <div class="bg-layer bg-layer-1"></div>
    <div class="bg-layer bg-layer-2"></div>
    <div class="bg-layer bg-layer-3"></div>
    <div class="clouds-container" id="cloudsContainer"></div>
  </div>

  <!-- Frog Animation Layer -->
  <canvas id="frogCanvas"></canvas>

  <header></header>
  
  <main>
    <div class="logo-container" id="logoContainer">
      <!-- Canvas for eye-tracking spritesheet rendering; replaces static img -->
      <canvas id="spudzCanvas" width="180" height="180" aria-label="Badgey" role="img"></canvas>
      <span class="ow-text" id="owText">OW!</span>
    </div>

    <div class="buttons">
      <a href="https://go.badgey.org" class="btn">Go</a>
      <a href="https://flashcards.badgey.org" class="btn btn-secondary">Flashcards</a>
    </div>
  </main>

  <footer>
    <button class="other-toggle" id="otherToggle">other</button>
    <div class="other-links" id="otherLinks">
      <a href="https://quest.badgey.org">Quest</a>
      <a href="https://sprite.badgey.org">Sprite</a>
      <a href="https://draw.badgey.org">SVG Draw</a>
      <a href="https://app.badgey.org">Gmail Tool</a>
      <a href="https://piano.badgey.org">Piano</a>
      <a href="https://conferences.badgey.org">Conferences</a>
      <a href="https://lisa.badgey.org">Lisa Bar Low</a>
      <a href="https://settings.badgey.org">Settings</a>
      <a href="https://badgercite.com">Badgercite</a>
    </div>
  </footer>

  <script>
    // =============================================================================
    // SPUDZ EYE-TRACKING SYSTEM
    // =============================================================================
    // Spritesheet: spudz_eyez_4096x5120.png (4096×5120, 8 cols × 10 rows, 512×512 per cell)
    //   - Columns (0-7): horizontal gaze direction (left → right)
    //   - Rows (0-9): vertical gaze direction (up → down)
    //   - Center gaze: approximately col=3-4, row=4-5
    //
    // Tunable constants below for range, smoothing, and idle drift behavior.
    // Wince state overrides idle-follow: on click, show OW image for 500ms.
    // =============================================================================

    // --- TUNABLE CONSTANTS ---
    const RANGE_PX = 250;              // Pixel distance to normalize cursor offset to [-1, 1]
    const SMOOTHING_ALPHA = 0.15;      // Lerp speed for eye movement (0-1, higher = faster)
    const IDLE_DRIFT_MIN_MS = 2000;    // Minimum time between idle gaze shifts
    const IDLE_DRIFT_MAX_MS = 4000;    // Maximum time between idle gaze shifts
    const IDLE_DRIFT_RANGE = 2;        // Max grid cells from center for idle drift
    const WINCE_DURATION_MS = 500;     // How long wince state lasts
    const SPRITESHEET_SCALE = 1.1;     // Scale factor for spritesheet frames to match OW size (1.0 = no scale)

    // --- SPRITESHEET CONSTANTS ---
    const SPRITE_COLS = 8;
    const SPRITE_ROWS = 10;
    const SPRITE_CELL_SIZE = 512;  // 512x512 cells in 4096x5120 sheet
    const CENTER_COL = 3.5;  // Center of horizontal gaze
    const CENTER_ROW = 4.5;  // Center of vertical gaze

    // --- DOM ELEMENTS ---
    const canvas = document.getElementById('spudzCanvas');
    const ctx = canvas.getContext('2d');
    const owText = document.getElementById('owText');
    const logoContainer = document.getElementById('logoContainer');
    const otherToggle = document.getElementById('otherToggle');
    const otherLinks = document.getElementById('otherLinks');

    // --- STATE ---
    let state = 'idle_follow';  // 'idle_follow' | 'wince'
    let smoothedDx = 0;         // Smoothed normalized X offset [-1, 1]
    let smoothedDy = 0;         // Smoothed normalized Y offset [-1, 1]
    let targetDx = 0;           // Target X (from mouse or idle drift)
    let targetDy = 0;           // Target Y (from mouse or idle drift)
    let hasMouseActivity = false;  // True if mouse is actively tracking
    let idleDriftTimeout = null;
    let winceTimeout = null;

    // --- IMAGE PRELOADING ---
    const images = {
      spritesheet: null,
      idle: null,
      wince: null
    };
    let imagesLoaded = 0;
    const TOTAL_IMAGES = 3;

    function preloadImages() {
      const srcs = {
        spritesheet: '/spudz_eyez_4096x5120.png',
        idle: '/spudz_free.png',
        wince: '/spudz_free_OW.png'
      };
      for (const [key, src] of Object.entries(srcs)) {
        const img = new Image();
        img.onload = () => {
          images[key] = img;
          imagesLoaded++;
          if (imagesLoaded === TOTAL_IMAGES) {
            startAnimationLoop();
          }
        };
        img.src = src;
      }
    }

    // --- CANVAS SIZING (DPR-aware) ---
    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      ctx.scale(dpr, dpr);
    }

    // --- GRID INDEX CALCULATION ---
    function clamp(val, min, max) {
      return Math.max(min, Math.min(max, val));
    }

    function getGridIndices(dx, dy) {
      // dx, dy are normalized to [-1, 1]
      // Convert to grid indices
      const col = Math.round(((dx + 1) / 2) * (SPRITE_COLS - 1));
      const row = Math.round(((dy + 1) / 2) * (SPRITE_ROWS - 1));
      return {
        col: clamp(col, 0, SPRITE_COLS - 1),
        row: clamp(row, 0, SPRITE_ROWS - 1)
      };
    }

    // --- IDLE DRIFT (when no mouse activity) ---
    function scheduleIdleDrift() {
      if (idleDriftTimeout) clearTimeout(idleDriftTimeout);
      const delay = IDLE_DRIFT_MIN_MS + Math.random() * (IDLE_DRIFT_MAX_MS - IDLE_DRIFT_MIN_MS);
      idleDriftTimeout = setTimeout(() => {
        if (!hasMouseActivity && state === 'idle_follow') {
          // Pick a random offset near center
          const offsetCol = (Math.random() - 0.5) * 2 * IDLE_DRIFT_RANGE;
          const offsetRow = (Math.random() - 0.5) * 2 * IDLE_DRIFT_RANGE;
          // Convert to normalized [-1, 1] space
          targetDx = offsetCol / (SPRITE_COLS / 2);
          targetDy = offsetRow / (SPRITE_ROWS / 2);
          targetDx = clamp(targetDx, -0.4, 0.4);  // Keep near center
          targetDy = clamp(targetDy, -0.4, 0.4);
        }
        scheduleIdleDrift();
      }, delay);
    }

    function resetToCenter() {
      targetDx = 0;
      targetDy = 0;
    }

    // --- MOUSE TRACKING ---
    let mouseActivityTimeout = null;

    function handleMouseMove(e) {
      if (state !== 'idle_follow') return;

      hasMouseActivity = true;
      if (mouseActivityTimeout) clearTimeout(mouseActivityTimeout);
      mouseActivityTimeout = setTimeout(() => {
        hasMouseActivity = false;
        resetToCenter();
      }, 3000);  // Consider mouse inactive after 3s of no movement

      const rect = canvas.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;

      const dx = e.clientX - centerX;
      const dy = e.clientY - centerY;

      // Normalize to [-1, 1] based on RANGE_PX
      targetDx = clamp(dx / RANGE_PX, -1, 1);
      targetDy = clamp(dy / RANGE_PX, -1, 1);
    }

    function handleMouseLeave() {
      hasMouseActivity = false;
      resetToCenter();
    }

    // --- RENDERING ---
    function render() {
      const displayWidth = canvas.getBoundingClientRect().width;
      const displayHeight = canvas.getBoundingClientRect().height;

      ctx.clearRect(0, 0, displayWidth, displayHeight);

      if (state === 'wince' && images.wince) {
        // Draw wince image
        ctx.drawImage(images.wince, 0, 0, displayWidth, displayHeight);
      } else if (images.spritesheet) {
        // Draw eye-tracking frame from spritesheet (scaled to match OW size)
        const { col, row } = getGridIndices(smoothedDx, smoothedDy);
        const sx = col * SPRITE_CELL_SIZE;
        const sy = row * SPRITE_CELL_SIZE;
        const scaledW = displayWidth * SPRITESHEET_SCALE;
        const scaledH = displayHeight * SPRITESHEET_SCALE;
        const offsetX = (displayWidth - scaledW) / 2;
        const offsetY = (displayHeight - scaledH) / 2;
        ctx.drawImage(
          images.spritesheet,
          sx, sy, SPRITE_CELL_SIZE, SPRITE_CELL_SIZE,
          offsetX, offsetY, scaledW, scaledH
        );
      } else if (images.idle) {
        // Fallback to idle image while spritesheet loads
        ctx.drawImage(images.idle, 0, 0, displayWidth, displayHeight);
      }
    }

    // --- ANIMATION LOOP ---
    function animationLoop() {
      // Smooth lerp toward target
      smoothedDx += (targetDx - smoothedDx) * SMOOTHING_ALPHA;
      smoothedDy += (targetDy - smoothedDy) * SMOOTHING_ALPHA;

      render();
      requestAnimationFrame(animationLoop);
    }

    function startAnimationLoop() {
      resizeCanvas();
      scheduleIdleDrift();
      animationLoop();
    }

    // --- CLICK HANDLER (WINCE) ---
    logoContainer.addEventListener('click', () => {
      // Set state to wince, overriding eye tracking
      state = 'wince';
      owText.classList.add('show');

      // Clear any pending wince timeout
      if (winceTimeout) clearTimeout(winceTimeout);

      winceTimeout = setTimeout(() => {
        state = 'idle_follow';
        owText.classList.remove('show');
      }, WINCE_DURATION_MS);
    });

    // --- EVENT LISTENERS ---
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseleave', handleMouseLeave);
    window.addEventListener('resize', resizeCanvas);

    // --- INITIALIZATION ---
    preloadImages();

    // --- OTHER LINKS TOGGLE (existing functionality) ---
    otherToggle.addEventListener('click', () => {
      otherLinks.classList.toggle('show');
      otherToggle.textContent = otherLinks.classList.contains('show') ? 'hide' : 'other';
    });

    // --- FLOATING CLOUDS ---
    (function initClouds() {
      const container = document.getElementById('cloudsContainer');
      if (!container) return;

      const cloudImages = [
        'bg/cloud1.png', 'bg/cloud2.png', 'bg/cloud3.png', 'bg/cloud4.png',
        'bg/cloud5.png', 'bg/cloud6.png', 'bg/cloud7.png', 'bg/cloud8.png'
      ];

      // Spawn 6-8 clouds at various positions
      const cloudCount = 6 + Math.floor(Math.random() * 3);
      
      for (let i = 0; i < cloudCount; i++) {
        const cloud = document.createElement('div');
        cloud.className = 'cloud';
        
        // Random cloud image
        const imgSrc = cloudImages[Math.floor(Math.random() * cloudImages.length)];
        cloud.style.backgroundImage = `url('${imgSrc}')`;
        
        // Random size (80-200px width)
        const size = 80 + Math.random() * 120;
        cloud.style.width = `${size}px`;
        cloud.style.height = `${size * 0.6}px`;
        
        // Random vertical position (top 60% of screen)
        cloud.style.top = `${Math.random() * 50}%`;
        
        // Random starting horizontal position
        cloud.style.left = `${-10 + Math.random() * 100}%`;
        
        // Gentle drift animation (60-120 seconds per cycle)
        const duration = 60 + Math.random() * 60;
        const delay = Math.random() * -duration; // Stagger start times
        const direction = Math.random() > 0.5 ? 'normal' : 'reverse';
        
        cloud.style.animation = `drift-slow ${duration}s linear ${delay}s infinite ${direction}`;
        cloud.style.opacity = 0.5 + Math.random() * 0.4;
        
        container.appendChild(cloud);
      }
    })();

    // =============================================================================
    // TOXIC FROG ANIMATION SYSTEM
    // =============================================================================
    // Frogs spawn randomly at screen edges, hop around with parabolic arcs,
    // and explode when clicked. They avoid landing on the logo and buttons.
    // Frogs prefer the bottom half (mountains). When in the top half, they
    // levitate with a gentle wobble and soft glow. Shadows appear on ground.
    // =============================================================================

    (function initFrogs() {
      // --- CONFIGURATION ---
      const FROG_CONFIG = {
        tileWidth: 48,
        tileHeight: 48,
        sheetColumns: 9,
        sheetRows: 5,
        displayScaleMin: 1.8,     // Random scale range
        displayScaleMax: 3.2,
        maxFrogsDesktop: 8,       // 25% fewer
        maxFrogsMobile: 3,        // 25% fewer
        spawnIntervalMin: 10000,
        spawnIntervalMax: 20000,
        hopDuration: 800,
        hopHeight: 20,
        maxHopDistance: 200,
        idleDelayMin: 3000,
        idleDelayMax: 8000,
        mobileBreakpoint: 768,
        // Levitation settings
        wobbleSpeed: 0.002,       // Radians per ms (slow, calm)
        wobbleAmplitude: 3,       // Pixels of wobble
        glowRadiusMin: 10,        // Min glow blur at midpoint
        glowRadiusMax: 40,        // Max glow blur at top of screen
        glowColor: 'rgba(255, 255, 255, 0.4)',
        // Shadow settings
        shadowOffsetY: 2,         // Subtle shadow right under frog
        shadowColor: 'rgba(0, 0, 0, 0.15)',
        // Hurt/click settings
        hurtDuration: 500
      };

      const ANIMATIONS = {
        idle:      { rowIndex: 0, startCol: 0, frameCount: 8, fps: 8, loop: true },
        hop:       { rowIndex: 1, startCol: 0, frameCount: 7, fps: 10, loop: false },
        hurt:      { rowIndex: 3, startCol: 0, frameCount: 4, fps: 10, loop: false },
        exploding: { rowIndex: 4, startCol: 0, frameCount: 9, fps: 12, loop: false }
      };

      const VARIANTS = ['BlueBlue', 'BlueBrown', 'GreenBlue', 'GreenBrown', 'PurpleBlue', 'PurpleWhite'];
      
      // Shuffle function for better variant distribution
      function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
      }
      
      // Track last used variants to avoid repeats
      let variantQueue = [];
      function getRandomVariant() {
        if (variantQueue.length === 0) {
          variantQueue = shuffleArray([...VARIANTS]);
        }
        return variantQueue.pop();
      }

      // --- STATE ---
      const frogCanvas = document.getElementById('frogCanvas');
      const frogCtx = frogCanvas.getContext('2d');
      const frogs = [];
      const frogSheets = {};  // variant -> Image
      let sheetsLoaded = 0;
      let exclusionZones = [];  // Array of {x, y, width, height}
      let lastTime = 0;
      let globalTime = 0;  // For wobble animation

      // --- PRELOAD SPRITESHEETS ---
      function preloadFrogSheets(callback) {
        VARIANTS.forEach(variant => {
          const img = new Image();
          img.onload = () => {
            frogSheets[variant] = img;
            sheetsLoaded++;
            if (sheetsLoaded === VARIANTS.length) {
              callback();
            }
          };
          img.onerror = () => {
            console.warn(`Failed to load frog sheet: ${variant}`);
            sheetsLoaded++;
            if (sheetsLoaded === VARIANTS.length) {
              callback();
            }
          };
          img.src = `toxic_frog/${variant}/ToxicFrog${variant}_Sheet.png`;
        });
      }

      // --- CANVAS SIZING ---
      function resizeFrogCanvas() {
        const dpr = window.devicePixelRatio || 1;
        frogCanvas.width = window.innerWidth * dpr;
        frogCanvas.height = window.innerHeight * dpr;
        frogCanvas.style.width = window.innerWidth + 'px';
        frogCanvas.style.height = window.innerHeight + 'px';
        frogCtx.setTransform(1, 0, 0, 1, 0, 0);
        frogCtx.scale(dpr, dpr);
        updateExclusionZones();
      }

      // --- EXCLUSION ZONES ---
      function updateExclusionZones() {
        exclusionZones = [];
        const logoEl = document.querySelector('.logo-container');
        const buttonsEl = document.querySelector('.buttons');
        
        if (logoEl) {
          const rect = logoEl.getBoundingClientRect();
          exclusionZones.push({
            x: rect.left,
            y: rect.top,
            width: rect.width,
            height: rect.height
          });
        }
        if (buttonsEl) {
          const rect = buttonsEl.getBoundingClientRect();
          exclusionZones.push({
            x: rect.left,
            y: rect.top,
            width: rect.width,
            height: rect.height
          });
        }
      }

      function isInExclusionZone(x, y, scale) {
        const frogSize = FROG_CONFIG.tileWidth * scale;
        const centerX = x + frogSize / 2;
        const centerY = y + frogSize / 2;
        
        for (const zone of exclusionZones) {
          if (centerX >= zone.x && centerX <= zone.x + zone.width &&
              centerY >= zone.y && centerY <= zone.y + zone.height) {
            return true;
          }
        }
        return false;
      }

      // --- HELPER: Check if Y position is in top half (levitating) ---
      function isLevitating(y, frogHeight) {
        const centerY = y + frogHeight / 2;
        return centerY < window.innerHeight / 2;
      }

      // --- HELPER: Get levitation amount (0 at midpoint, 1 at top) ---
      function getLevitationAmount(y, frogHeight) {
        const centerY = y + frogHeight / 2;
        const midpoint = window.innerHeight / 2;
        if (centerY >= midpoint) return 0;
        // How far above midpoint (0 to 1)
        return Math.min(1, (midpoint - centerY) / midpoint);
      }

      // --- FROG CLASS ---
      class Frog {
        constructor(x, y, variant) {
          this.x = x;
          this.y = y;
          this.variant = variant;
          this.state = 'idle';
          this.frameIndex = 0;
          this.frameTimer = 0;
          this.hopProgress = 0;
          this.hopStartX = x;
          this.hopStartY = y;
          this.targetX = x;
          this.targetY = y;
          this.hopTimeout = null;
          this.facingLeft = Math.random() > 0.5;
          // Random scale for each frog
          this.scale = FROG_CONFIG.displayScaleMin + 
            Math.random() * (FROG_CONFIG.displayScaleMax - FROG_CONFIG.displayScaleMin);
          // Wobble phase offset (randomized so frogs don't wobble in sync)
          this.wobblePhase = Math.random() * Math.PI * 2;
          // Click tracking: requires 2 clicks to explode
          this.clickCount = 0;
          // Hurt state tracking
          this.hurtTimer = 0;
          this.scheduleNextHop();
        }

        scheduleNextHop() {
          const delay = FROG_CONFIG.idleDelayMin + 
            Math.random() * (FROG_CONFIG.idleDelayMax - FROG_CONFIG.idleDelayMin);
          this.hopTimeout = setTimeout(() => this.startHop(), delay);
        }

        startHop() {
          if (this.state === 'exploding' || this.state === 'hurt') return;
          
          const frogSize = FROG_CONFIG.tileWidth * this.scale;
          const margin = frogSize;
          const maxDist = FROG_CONFIG.maxHopDistance;
          let attempts = 0;
          let targetX, targetY;
          
          do {
            // Bias toward bottom half of screen (70% chance to target bottom half)
            const preferBottom = Math.random() < 0.7;
            const angle = Math.random() * Math.PI * 2;
            const distance = 50 + Math.random() * (maxDist - 50);
            targetX = this.x + Math.cos(angle) * distance;
            targetY = this.y + Math.sin(angle) * distance;
            
            // If preferring bottom, bias Y toward bottom half
            if (preferBottom) {
              const bottomHalf = window.innerHeight / 2;
              if (targetY < bottomHalf) {
                targetY = bottomHalf + Math.random() * (window.innerHeight / 2 - margin - frogSize);
              }
            }
            
            // Clamp to screen bounds
            targetX = Math.max(margin, Math.min(window.innerWidth - margin - frogSize, targetX));
            targetY = Math.max(margin, Math.min(window.innerHeight - margin - frogSize, targetY));
            attempts++;
          } while (isInExclusionZone(targetX, targetY, this.scale) && attempts < 20);
          
          this.hopStartX = this.x;
          this.hopStartY = this.y;
          this.targetX = targetX;
          this.targetY = targetY;
          this.hopProgress = 0;
          this.state = 'hop';
          this.frameIndex = 0;
          this.frameTimer = 0;
          
          if (this.targetX < this.x) {
            this.facingLeft = true;
          } else if (this.targetX > this.x) {
            this.facingLeft = false;
          }
        }

        triggerHurt() {
          if (this.state === 'exploding') return;
          if (this.hopTimeout) clearTimeout(this.hopTimeout);
          this.state = 'hurt';
          this.frameIndex = 0;
          this.frameTimer = 0;
          this.hurtTimer = FROG_CONFIG.hurtDuration;
        }

        // Handle click - first click hurts, second click explodes
        handleClick() {
          if (this.state === 'exploding') return false;
          this.clickCount++;
          if (this.clickCount >= 2) {
            this.explode();
          } else {
            this.triggerHurt();
          }
          return true;
        }

        explode() {
          if (this.state === 'exploding') return;
          if (this.hopTimeout) clearTimeout(this.hopTimeout);
          this.state = 'exploding';
          this.frameIndex = 0;
          this.frameTimer = 0;
        }

        update(deltaTime) {
          const anim = ANIMATIONS[this.state];
          if (!anim) return;

          // Handle hurt timer
          if (this.state === 'hurt') {
            this.hurtTimer -= deltaTime;
            if (this.hurtTimer <= 0) {
              this.state = 'idle';
              this.frameIndex = 0;
              this.frameTimer = 0;
              this.scheduleNextHop();
            }
          }

          // Update frame
          const frameDuration = 1000 / anim.fps;
          this.frameTimer += deltaTime;
          
          if (this.frameTimer >= frameDuration) {
            this.frameTimer -= frameDuration;
            this.frameIndex++;
            
            if (this.frameIndex >= anim.frameCount) {
              if (anim.loop) {
                this.frameIndex = 0;
              } else if (this.state === 'exploding') {
                this.frameIndex = anim.frameCount - 1;
                this.dead = true;
              } else if (this.state === 'hop') {
                this.frameIndex = 0;
              } else if (this.state === 'hurt') {
                this.frameIndex = anim.frameCount - 1;  // Hold last frame
              }
            }
          }

          // Update position during hop
          if (this.state === 'hop') {
            const frogHeight = FROG_CONFIG.tileHeight * this.scale;
            const levitating = isLevitating(this.y, frogHeight);
            
            // Slower hop progress when levitating (less gravity feel)
            const speedMultiplier = levitating ? 0.7 : 1.0;
            this.hopProgress += (deltaTime / FROG_CONFIG.hopDuration) * speedMultiplier;
            
            if (this.hopProgress >= 1) {
              this.hopProgress = 1;
              this.x = this.targetX;
              this.y = this.targetY;
              this.state = 'idle';
              this.frameIndex = 0;
              this.frameTimer = 0;
              this.scheduleNextHop();
            } else {
              const t = this.hopProgress;
              this.x = this.hopStartX + (this.targetX - this.hopStartX) * t;
              const baseY = this.hopStartY + (this.targetY - this.hopStartY) * t;
              // Reduced arc height when levitating
              const arcMultiplier = levitating ? 0.5 : 1.0;
              const arcOffset = -4 * FROG_CONFIG.hopHeight * arcMultiplier * t * (1 - t);
              this.y = baseY + arcOffset;
            }
          }
        }

        draw(ctx) {
          const sheet = frogSheets[this.variant];
          if (!sheet) return;

          const anim = ANIMATIONS[this.state];
          if (!anim) return;

          const col = anim.startCol + this.frameIndex;
          const row = anim.rowIndex;
          const sx = col * FROG_CONFIG.tileWidth;
          const sy = row * FROG_CONFIG.tileHeight;
          const dw = FROG_CONFIG.tileWidth * this.scale;
          const dh = FROG_CONFIG.tileHeight * this.scale;
          
          const frogHeight = FROG_CONFIG.tileHeight * this.scale;
          const levitating = isLevitating(this.y, frogHeight);
          
          // Calculate wobble offset for levitating frogs
          let wobbleOffset = 0;
          if (levitating && this.state !== 'exploding') {
            wobbleOffset = Math.sin(globalTime * FROG_CONFIG.wobbleSpeed + this.wobblePhase) 
                           * FROG_CONFIG.wobbleAmplitude;
          }

          ctx.save();
          
          // Draw shadow if on ground (bottom half) and not exploding
          if (!levitating && this.state !== 'exploding') {
            ctx.save();
            ctx.globalAlpha = 0.15;
            ctx.fillStyle = FROG_CONFIG.shadowColor;
            // Subtle elliptical shadow right beneath frog
            const shadowWidth = dw * 0.5;
            const shadowHeight = dh * 0.12;
            const shadowX = this.x + dw / 2;
            const shadowY = this.y + dh - FROG_CONFIG.shadowOffsetY;
            ctx.beginPath();
            ctx.ellipse(shadowX, shadowY, shadowWidth / 2, shadowHeight / 2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          }
          
          // Apply glow effect for levitating frogs - intensity based on height
          if (levitating && this.state !== 'exploding') {
            const levAmount = getLevitationAmount(this.y, frogHeight);
            const glowRadius = FROG_CONFIG.glowRadiusMin + 
              (FROG_CONFIG.glowRadiusMax - FROG_CONFIG.glowRadiusMin) * levAmount;
            ctx.shadowBlur = glowRadius;
            ctx.shadowColor = FROG_CONFIG.glowColor;
          }
          
          const drawY = this.y + wobbleOffset;
          
          if (this.facingLeft) {
            ctx.translate(this.x + dw, drawY);
            ctx.scale(-1, 1);
            ctx.drawImage(
              sheet,
              sx, sy, FROG_CONFIG.tileWidth, FROG_CONFIG.tileHeight,
              0, 0, dw, dh
            );
          } else {
            ctx.drawImage(
              sheet,
              sx, sy, FROG_CONFIG.tileWidth, FROG_CONFIG.tileHeight,
              this.x, drawY, dw, dh
            );
          }
          
          ctx.restore();
        }

        containsPoint(px, py) {
          const dw = FROG_CONFIG.tileWidth * this.scale;
          const dh = FROG_CONFIG.tileHeight * this.scale;
          return px >= this.x && px <= this.x + dw &&
                 py >= this.y && py <= this.y + dh;
        }
      }

      // --- SPAWNING ---
      function getMaxFrogs() {
        return window.innerWidth < FROG_CONFIG.mobileBreakpoint 
          ? FROG_CONFIG.maxFrogsMobile 
          : FROG_CONFIG.maxFrogsDesktop;
      }

      function spawnFrog() {
        if (frogs.length >= getMaxFrogs()) {
          scheduleNextSpawn();
          return;
        }

        // Prefer spawning from bottom/sides (80% bottom half of edges)
        const preferBottom = Math.random() < 0.8;
        const tempScale = FROG_CONFIG.displayScaleMin + 
          Math.random() * (FROG_CONFIG.displayScaleMax - FROG_CONFIG.displayScaleMin);
        const frogSize = FROG_CONFIG.tileWidth * tempScale;
        
        // Weighted edge selection: favor bottom and sides
        const edgeRoll = Math.random();
        let edge;
        if (edgeRoll < 0.4) edge = 2;       // 40% bottom
        else if (edgeRoll < 0.65) edge = 1; // 25% right
        else if (edgeRoll < 0.9) edge = 3;  // 25% left
        else edge = 0;                       // 10% top
        
        let x, y;
        
        switch (edge) {
          case 0: // Top
            x = Math.random() * (window.innerWidth - frogSize);
            y = -frogSize;
            break;
          case 1: // Right
            x = window.innerWidth;
            y = preferBottom 
              ? window.innerHeight / 2 + Math.random() * (window.innerHeight / 2 - frogSize)
              : Math.random() * (window.innerHeight - frogSize);
            break;
          case 2: // Bottom
            x = Math.random() * (window.innerWidth - frogSize);
            y = window.innerHeight;
            break;
          case 3: // Left
            x = -frogSize;
            y = preferBottom 
              ? window.innerHeight / 2 + Math.random() * (window.innerHeight / 2 - frogSize)
              : Math.random() * (window.innerHeight - frogSize);
            break;
        }

        const variant = getRandomVariant();
        const frog = new Frog(x, y, variant);
        frog.scale = tempScale;  // Use the pre-calculated scale
        
        frog.startHop();
        frogs.push(frog);
        
        scheduleNextSpawn();
      }

      function scheduleNextSpawn() {
        const delay = FROG_CONFIG.spawnIntervalMin + 
          Math.random() * (FROG_CONFIG.spawnIntervalMax - FROG_CONFIG.spawnIntervalMin);
        setTimeout(spawnFrog, delay);
      }

      // --- CLICK HANDLING ---
      function handleClick(e) {
        const x = e.clientX;
        const y = e.clientY;
        
        // Check frogs in reverse order (top-most first)
        for (let i = frogs.length - 1; i >= 0; i--) {
          if (frogs[i].containsPoint(x, y) && frogs[i].state !== 'exploding') {
            frogs[i].handleClick();
            e.stopPropagation();
            e.preventDefault();
            return;
          }
        }
      }

      // --- HOVER HANDLING (cursor change) ---
      function handleMouseMove(e) {
        const x = e.clientX;
        const y = e.clientY;
        
        let overFrog = false;
        for (let i = frogs.length - 1; i >= 0; i--) {
          if (frogs[i].containsPoint(x, y) && frogs[i].state !== 'exploding') {
            overFrog = true;
            break;
          }
        }
        
        document.body.style.cursor = overFrog ? 'pointer' : '';
      }

      // --- RENDER LOOP ---
      function frogAnimationLoop(currentTime) {
        if (!lastTime) lastTime = currentTime;
        const deltaTime = currentTime - lastTime;
        lastTime = currentTime;
        globalTime = currentTime;  // Update global time for wobble

        frogCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);

        // Update and draw frogs
        for (let i = frogs.length - 1; i >= 0; i--) {
          frogs[i].update(deltaTime);
          if (frogs[i].dead) {
            frogs.splice(i, 1);
          } else {
            frogs[i].draw(frogCtx);
          }
        }

        requestAnimationFrame(frogAnimationLoop);
      }

      // --- INITIALIZATION ---
      function init() {
        resizeFrogCanvas();
        window.addEventListener('resize', resizeFrogCanvas);
        // Use capture phase so frog clicks are detected before other handlers
        document.addEventListener('click', handleClick, true);
        // Track mouse for cursor change
        document.addEventListener('mousemove', handleMouseMove);
        
        preloadFrogSheets(() => {
          // Start spawning after a short initial delay
          setTimeout(spawnFrog, 3000);
          requestAnimationFrame(frogAnimationLoop);
        });
      }

      init();
    })();
  </script>
</body>
</html>
